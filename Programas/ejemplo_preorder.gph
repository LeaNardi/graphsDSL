g := graph [
    ("A", [("B", 7), ("D", 5)]),
    ("B", [("E", 7), ("A", 7)]),
    ("C", [("E", 5)]),
    ("D", [("F", 6), ("A", 5)]),
    ("E", [("G", 9), ("B", 7), ("C", 5)]),
    ("F", [("D", 6)]),
    ("G", [("E", 9)])
    ];
print "Grafo para recorrido preorder:";
print g;
visualize(g, "Grafo_Ejemplo_Preorder");

startNode := "A";
preorderResult := emptyList;
visited := emptyList;

// Esto es una pila 
stack := emptyList;
stack := appendList(stack, startNode);

// Mientras la pila no esté vacía...
while !isEmptyList(stack) do
    current := lastList(stack);
    stack := initList(stack);
    
    cond inList(current, visited) then
        skip
    else
        visited := appendList(visited, current);
        
        preorderResult := appendList(preorderResult, current);
        
        neighbors := adjacentNodes(g, current);
        
        // Pusimos una lista a funcionar como pila, asi que invertimos el orden para asegurar el comportamiento como pila...
        neighborsReversed := reverseList(neighbors);
        
        for neighbor in neighborsReversed do
            cond inList(neighbor, visited) then
                skip
            else
                stack := appendList(stack, neighbor)
            end
        end
    end
end;

print "Resultado Preorder: ";
print preorderResult

