// Problema TSP (Traveling Salesman Problem) aplicado a recoleccion de residuos


// GRAFO URBANO (Cuadrícula 4x4 con pesos)

g := graph[
  ("A1", [("A2",99),("B1",1)]),
  ("A2", [("A1",99),("A3",1),("B2",1)]),
  ("A3", [("A2",1),("B3",1)]),

  ("B1", [("A1",1),("B2",1)]),
  ("B2", [("B1",1),("A2",1),("B3",1)]),
  ("B3", [("B2",1),("A3",1)])
];

// OPCIONAL: Simular cortes de calle

// g2 := deleteEdge(g, edge("B2", "C2"));
// g2 := deleteEdge(g2, edge("C3", "D3"));

// Si no hay cortes, g2 = g
g2 := g;

print "Grafo urbano inicial:";
print g2;
visualize(g2, "GrafoUrbano");


// ===============================================
// 1) VERIFICAR CONECTIVIDAD GLOBAL
// Si no es conexo, se cancela el TSP inmediatamente

cond esConexo(g2) then
    skip
else
    print "ERROR: Hay barrios inaccesibles. No se puede planificar la ruta."
end;


// 2) CLAUSURA MÉTRICA
// Convertimos g2 en un grafo completo con distancias mínimas

gMetric := metricClosure(g2);

print "Grafo clausura metrica:";
print gMetric;
visualize(gMetric, "GrafoMetric");


// 3) TSP Aproximado usando MST (Minimum Spanning Tree) + DFS (Depth First Search)


// 3.1. Obtener aristas ordenadas
edges := sortByWeight(getEdges(gMetric));


// 3.2. Inicializar Union-Find
uf := unionfind[
 ("A1","A1"),("A2","A2"),("A3","A3"),
 ("B1","B1"),("B2","B2"),("B3","B3")
];


// 3.3 Construir MST con Kruskal
mst := emptyList;

for e in edges do
    n1 := getNode1(e);
    n2 := getNode2(e);
    r1 := find(n1, uf);
    r2 := find(n2, uf);

    cond (r1 == r2) then
        skip
    else
        uf := union(r1, r2, uf);
        mst := addList(mst, e)
    end
end;

print "MST construido:";
print mst;


// 4) RECORRIDO FINAL (DFS sobre MST = TSP Aproximado)

queue2 := queue [];
visited2 := emptyList;

// enqueue inicial
queue2 := enqueue(queue2, "A1");

while !isEmptyQueue(queue2) do
    x := peek(queue2);
    queue2 := dequeue(queue2);

    cond inList(x, visited2) then
        skip
    else
        visited2 := addList(visited2, x);

        for e in mst do
            a := getNode1(e);
            b := getNode2(e);

            cond (a == x) then
                queue2 := enqueue(queue2, b)
            else
                skip
            end;

            cond (b == x) then
                queue2 := enqueue(queue2, a)
            else
                skip
            end
        end
    end
end;

print "Recorrido TSP aproximado:";
print visited2;

// 5) Cálculo del costo total del recorrido TSP
// usando únicamente la clausura métrica

print "==== CALCULO DEL COSTO DEL RECORRIDO ====";

// Inicializar costo
total := 0;

// Obtener todas las aristas del grafo métrico
edgesMetric := getEdges(gMetric);

// Si por algún motivo no hay recorrido, no hacemos nada
cond isEmptyList(visited2) then
    print "No hay recorrido."
else
    // Tomamos el primer nodo y el resto
    prev := headList(visited2);
    rest := tailList(visited2);

    while !isEmptyList(rest) do
        next := headList(rest);

        // Buscamos la distancia mínima entre prev y next
        w := 0;
        foundEdge := 0;

        for e in edgesMetric do
            cond (foundEdge == 0) then
                u := getNode1(e);
                v := getNode2(e);

                // Comparación métrica: edge(u,v)
                cond ((u == prev) && (v == next)) then
                    w := getWeight(e);
                    foundEdge := 1
                else
                    cond ((u == next) && (v == prev)) then
                        w := getWeight(e);
                        foundEdge := 1
                    else
                        skip
                    end
                end
            else
                skip
            end
        end;

        total := total + w;

        // Avanzamos
        prev := next;
        rest := tailList(rest)
    end
end;

print "Costo total del recorrido:";
print total;

// 6) RECONSTRUCCIÓN DEL CAMINO FISICO REAL EN g2

print "Reconstrucción del camino real:";

// Lista vacía donde concatenamos el recorrido físico real
caminoReal := emptyList;

// Obtener el camino hamiltoniano
cond isEmptyList(visited2) then
    skip
else
    prev := headList(visited2);
    rest := tailList(visited2);

    while !isEmptyList(rest) do
        next := headList(rest);

        // Reconstruimos el camino real entre prev y next con BFS
        // -----------------------------------------------------

        // Inicializamos estructuras
        q := queue[];
        q := enqueue(q, prev);

        visited := emptyList;
        parent := emptyList;   // lista de pares (nodo, padre)

        found := 0;

        while !isEmptyQueue(q) do
            x := peek(q);
            q := dequeue(q);

            cond inList(x, visited) then
                skip
            else
                visited := addList(visited, x);

                // si encontramos el destino terminamos BFS
                cond (x == next) then
                    found := 1
                else
                    neigh := adjacentNodes(g2, x);

                    for y in neigh do
                        cond inList(y, visited) then
                            skip
                        else
                            // check si ya tiene padre registrado
                            hasParent := 0;
                            for p in parent do
                                cond (getNode1(p) == y) then
                                    hasParent := 1
                                else
                                    skip
                                end
                            end;

                            cond (hasParent == 0) then
                                // y no visitado y sin padre → lo agregamos a la cola
                                q := enqueue(q, y);
                                // registramos padre usando edge
                                parent := addList(parent, edge(y, x, 0))
                            else
                                skip
                            end
                        end
                    end
                end
            end;

            cond (found == 1) then
                // salimos del while externo
                q := queue[]    // forzamos corte
            else
                skip
            end
        end;

              // Reconstrucción final: backtracking del camino

        segmento := emptyList;
        actual := next;

        // armamos camino invertido: next → prev
        while !(actual == prev) do
            segmento := addList(segmento, actual);

            // buscamos su padre
            padre := prev; // para el compilador, default
            foundParent := 0;
            for p in parent do
                cond (foundParent == 0) then
                    nodoP := getNode1(p);    // el hijo
                    nodoPadre := getNode2(p); // el padre

                    cond (nodoP == actual) then
                        padre := nodoPadre;
                        foundParent := 1
                    else
                        skip
                    end
                else
                    skip
                end
            end;

            actual := padre
        end;

        // agregamos el nodo de inicio al final
        segmento := addList(segmento, prev);

        // segmento = [next, ..., prev] - necesitamos [prev, ..., next]
        // Para invertir con solo addList: leer elementos y reconstruir al revés
        segmentoInvertido := emptyList;
        
        // Método: para cada posición i desde el final hasta el inicio
        lenSeg := lenList(segmento);
        i := lenSeg;
        while (i > 0) do
            // obtener elemento en posición (i-1)
            tempList := segmento;
            j := 1;
            while (j < i) do
                tempList := tailList(tempList);
                j := j + 1
            end;
            elemento := headList(tempList);
            
            // agregar al final de invertido
            segmentoInvertido := addList(segmentoInvertido, elemento);
            i := i - 1
        end;

        // Ahora segmentoInvertido = [prev, ..., next] ✓

        // concatenamos al camino global (evitando duplicar nodos)
        cond isEmptyList(caminoReal) then
            // primer segmento: agregar todo
            for s in segmentoInvertido do
                caminoReal := addList(caminoReal, s)
            end
        else
            // segmentos siguientes: saltar primer nodo (ya está en caminoReal)
            segmentoSinPrimero := tailList(segmentoInvertido);
            for s in segmentoSinPrimero do
                caminoReal := addList(caminoReal, s)
            end
        end;

        // avanzar
        prev := next;
        rest := tailList(rest)
    end
end;

print "Camino físico real concatenado:";
print caminoReal