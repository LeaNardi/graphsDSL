// Problema TSP (Traveling Salesman Problem) aplicado a recoleccion de residuos


// GRAFO URBANO (Cuadr√≠cula 4x4 con pesos)

g := graph[
  ("A1", [("A2",5),("B1",7)]),
  ("A2", [("A1",5),("A3",4),("B2",6)]),
  ("A3", [("A2",4),("A4",8),("B3",3)]),
  ("A4", [("A3",8),("B4",5)]),

  ("B1", [("A1",7),("B2",2),("C1",3)]),
  ("B2", [("B1",2),("A2",6),("B3",5),("C2",4)]),
  ("B3", [("B2",5),("A3",3),("B4",6),("C3",7)]),
  ("B4", [("B3",6),("A4",5),("C4",5)]),

  ("C1", [("B1",3),("C2",5),("D1",4)]),
  ("C2", [("C1",5),("B2",4),("C3",2),("D2",3)]),
  ("C3", [("C2",2),("B3",7),("C4",4),("D3",6)]),
  ("C4", [("C3",4),("B4",5),("D4",7)]),

  ("D1", [("C1",4),("D2",3)]),
  ("D2", [("D1",3),("C2",3),("D3",5)]),
  ("D3", [("D2",5),("C3",6),("D4",4)]),
  ("D4", [("D3",4),("C4",7)])
];

// Nodo en el que comienza el recorrido
startNode := "A1";

// OPCIONAL: Simular cortes de calle

// g2 := deleteEdge(g, edge("B2", "C2"));
// g2 := deleteEdge(g2, edge("C3", "D3"));

// Si no hay cortes, g2 = g
g2 := g;

print "01 - Grafo urbano inicial:";
print g2;
visualize(g2, "01_GrafoUrbano");


// ===============================================
// 1) VERIFICAR CONECTIVIDAD GLOBAL
// Si no es conexo, se cancela el TSP inmediatamente

cond !esConexo(g2) then
    print "ERROR: Hay barrios inaccesibles. No se puede planificar la ruta."
end;


// 2) CLAUSURA MeTRICA
// Convertimos g2 en un grafo completo con distancias minimas

gMetric := metricClosure(g2);

print "02 - Grafo clausura metrica:";
print gMetric;
visualize(gMetric, "02_GrafoMetric");

gMetricPaths := metricClosurePaths(g2);
print("Paths de la clausura metrica:");
print(gMetricPaths);


// 3) TSP Aproximado usando MST (Minimum Spanning Tree) + DFS (Depth First Search)


// 3.1. Obtener aristas ordenadas
edges := sortByWeight(getEdges(gMetric));


// 3.2. Inicializar Union-Find
uf := unionfind[
 ("A1","A1"),("A2","A2"),("A3","A3"),("A4","A4"),
 ("B1","B1"),("B2","B2"),("B3","B3"),("B4","B4"),
 ("C1","C1"),("C2","C2"),("C3","C3"),("C4","C4"),
 ("D1","D1"),("D2","D2"),("D3","D3"),("D4","D4")
];


// 3.3 Construir MST con Kruskal
mst := graph [];

for e in edges do
    n1 := getNode1(e);
    n2 := getNode2(e);
    r1 := find(n1, uf);
    r2 := find(n2, uf);

    cond !(r1 == r2) then
        uf := union(r1, r2, uf);
        mst := addEdge(mst, e)
    end
end;

print "03 - MST construido:";
print mst;
visualize(mst, "03_MST");


// 4) RECORRIDO FINAL (DFS sobre MST = TSP Aproximado)

// Inicializar estructuras
preorderResult := emptyList;
visited := emptyList;

// Pila para Preorder
stack := emptyList;
stack := appendList(stack, startNode);

while !isEmptyList(stack) do
    current := lastList(stack);
    stack := initList(stack);
    
    cond !inList(current, visited) then
        visited := appendList(visited, current);
        
        // Visitar nodo
        preorderResult := appendList(preorderResult, current);
        
        // Obtener vecinos
        neighbors := adjacentNodes(mst, current);
        // Se invierten para asegurar el comportamiento como pila
        neighborsReversed := reverseList(neighbors);

        for neighbor in neighborsReversed do
            cond !inList(neighbor, visited) then
                stack := appendList(stack, neighbor)
            end
        end
    end
end;

print "DFS sobre MST:";
print preorderResult;


visited2 := appendList(preorderResult, startNode);
print "Recorrido TSP aproximado:";
print visited2;

// 5) Calculo del costo total del recorrido TSP
// usando unicamente la clausura metrica

print "==== CALCULO DEL COSTO DEL RECORRIDO ====";

// Inicializar costo
total := 0;

// Si por algun motivo no hay recorrido, no hacemos nada
cond isEmptyList(visited2) then
    print "No hay recorrido."
else
    // Tomamos el primer nodo y el resto
    prev := headList(visited2);
    rest := tailList(visited2);

    while !isEmptyList(rest) do
        next := headList(rest);

        // Buscamos la distancia minima entre prev y next
        w := 0;
        foundEdge := 0;

        forEdges e in gMetric do
            cond (foundEdge == 0) then
                u := getNode1(e);
                v := getNode2(e);

                // Comparacion metrica: edge(u,v)
                cond ((u == prev) && (v == next)) then
                    w := getWeight(e);
                    foundEdge := 1
                else
                    cond ((u == next) && (v == prev)) then
                        w := getWeight(e);
                        foundEdge := 1
                    end
                end
            end
        end;

        total := total + w;

        prev := next;
        rest := tailList(rest)
    end

end;

print "Costo total del recorrido:";
print total;

// 6) RECONSTRUCCIoN DEL CAMINO FISICO REAL EN g2

print "Reconstruccion del camino real:";

// Lista con el primer nodo
caminoReal := [startNode];

// Obtener el camino hamiltoniano
cond isEmptyList(visited2) then
    print "No hay recorrido."
else
    prev := headList(visited2);
    rest := tailList(visited2);
    
    while !isEmptyList(rest) do
        next := headList(rest);

        segmentoInvertido := emptyList;
        foundPath := 0;
        
        for pathInfo in gMetricPaths do
            cond (foundPath == 0) then
                source := headList(pathInfo);
                target := headList(tailList(pathInfo));
                path := lastList(pathInfo);
                
                cond ((source == prev) && (target == next)) then
                    segmentoInvertido := path;
                    foundPath := 1
                end
            end
        end;

        segmentoSinPrimero := tailList(segmentoInvertido);
        for s in segmentoSinPrimero do
            caminoReal := appendList(caminoReal, s)
        end;

        prev := next;
        rest := tailList(rest)
    end
end;

print "Camino fisico real concatenado:";
print caminoReal