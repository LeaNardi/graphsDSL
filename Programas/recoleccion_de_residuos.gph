// Problema TSP (Traveling Salesman Problem) aplicado a recoleccion de residuos


// GRAFO URBANO (Cuadrícula 4x4 con pesos)

g := graph[
  ("A1", [("A2",5),("B1",7)]),
  ("A2", [("A1",5),("A3",4),("B2",6)]),
  ("A3", [("A2",4),("A4",8),("B3",3)]),
  ("A4", [("A3",8),("B4",5)]),

  ("B1", [("A1",7),("B2",2),("C1",3)]),
  ("B2", [("B1",2),("A2",6),("B3",5),("C2",4)]),
  ("B3", [("B2",5),("A3",3),("B4",6),("C3",7)]),
  ("B4", [("B3",6),("A4",5),("C4",5)]),

  ("C1", [("B1",3),("C2",5),("D1",4)]),
  ("C2", [("C1",5),("B2",4),("C3",2),("D2",3)]),
  ("C3", [("C2",2),("B3",7),("C4",4),("D3",6)]),
  ("C4", [("C3",4),("B4",5),("D4",7)]),

  ("D1", [("C1",4),("D2",3)]),
  ("D2", [("D1",3),("C2",3),("D3",5)]),
  ("D3", [("D2",5),("C3",6),("D4",4)]),
  ("D4", [("D3",4),("C4",7)])
];

// OPCIONAL: Simular cortes de calle

// g2 := deleteEdge(g, edge("B2", "C2"));
// g2 := deleteEdge(g2, edge("C3", "D3"));

// Si no hay cortes, g2 = g
g2 := g;

print "Grafo urbano inicial:";
print g2;
visualize(g2, "GrafoUrbano");


// ===============================================
// 1) VERIFICAR CONECTIVIDAD GLOBAL
// Si no es conexo, se cancela el TSP inmediatamente

cond esConexo(g2) then
    skip
else
    print "ERROR: Hay barrios inaccesibles. No se puede planificar la ruta."
end;


// 2) CLAUSURA MÉTRICA
// Convertimos g2 en un grafo completo con distancias mínimas

gMetric := metricClosure(g2);

print "Grafo clausura metrica:";
print gMetric;
visualize(gMetric, "GrafoMetric");


// 3) TSP Aproximado usando MST (Minimum Spanning Tree) + DFS (Depth First Search)


// 3.1. Obtener aristas ordenadas
edges := sortByWeight(getEdges(gMetric));


// 3.2. Inicializar Union-Find
uf := unionfind[
 ("A1","A1"),("A2","A2"),("A3","A3"),("A4","A4"),
 ("B1","B1"),("B2","B2"),("B3","B3"),("B4","B4"),
 ("C1","C1"),("C2","C2"),("C3","C3"),("C4","C4"),
 ("D1","D1"),("D2","D2"),("D3","D3"),("D4","D4")
];


// 3.3 Construir MST con Kruskal
mst := emptyList;

for e in edges do
    n1 := getNode1(e);
    n2 := getNode2(e);
    r1 := find(n1, uf);
    r2 := find(n2, uf);

    cond (r1 == r2) then
        skip
    else
        uf := union(r1, r2, uf);
        mst := addList(mst, e)
    end
end;

print "MST construido:";
print mst;


// 4) RECORRIDO FINAL (DFS sobre MST = TSP Aproximado)

queue2 := queue [];
visited2 := emptyList;

// enqueue inicial
queue2 := enqueue(queue2, "A1");

while !isEmptyQueue(queue2) do
    x := peek(queue2);
    queue2 := dequeue(queue2);

    cond inList(x, visited2) then
        skip
    else
        visited2 := addList(visited2, x);

        for e in mst do
            a := getNode1(e);
            b := getNode2(e);

            cond (a == x) then
                queue2 := enqueue(queue2, b)
            else
                skip
            end;

            cond (b == x) then
                queue2 := enqueue(queue2, a)
            else
                skip
            end
        end
    end
end;

print "Recorrido TSP aproximado:";
print visited2;

// 5) Cálculo del costo total del recorrido TSP
// usando únicamente la clausura métrica

print "==== CALCULO DEL COSTO DEL RECORRIDO ====";

// Inicializar costo
total := 0;

// Obtener todas las aristas del grafo métrico
edgesMetric := getEdges(gMetric);

// Si por algún motivo no hay recorrido, no hacemos nada
cond isEmptyList(visited2) then
    print "No hay recorrido."
else
    // Tomamos el primer nodo y el resto
    prev := headList(visited2);
    rest := tailList(visited2);

    while !isEmptyList(rest) do
        next := headList(rest);

        // Buscamos la distancia mínima entre prev y next
        w := 0;
        foundEdge := 0;

        for e in edgesMetric do
            cond (foundEdge == 0) then
                u := getNode1(e);
                v := getNode2(e);

             // Comparación métrica: edge(u,v)
                cond ((u == prev) && (v == next)) then
                    w := getWeight(e);
                    foundEdge := 1
                else
                    cond ((u == next) && (v == prev)) then
                        w := getWeight(e);
                        foundEdge := 1
                    else
                        skip
                    end
                end
            else
                skip
            end
        end;

        total := total + w;

        // Avanzamos
        prev := next;
        rest := tailList(rest)
    end
end;

print "Costo total del recorrido:";
print total;

// 6) RECONSTRUCCIÓN DEL CAMINO FISICO REAL EN g2

print "Reconstrucción del camino real:";

// Lista vacía donde concatenamos el recorrido físico real
caminoReal := emptyList;

// Obtener el camino hamiltoniano
cond isEmptyList(visited2) then
    skip
else
    prev := headList(visited2);
    rest := tailList(visited2);

    while !isEmptyList(rest) do
        next := headList(rest);

        // Reconstruimos el camino real entre prev y next con BFS
        // -----------------------------------------------------

        // Inicializamos estructuras
        q := queue[];
        q := enqueue(q, prev);

        visited := emptyList;
        parent := emptyList;   // lista de pares (nodo, padre)

        found := 0;

        while !isEmptyQueue(q) do
            x := peek(q);
            q := dequeue(q);

            cond inList(x, visited) then
                skip
            else
                visited := addList(visited, x);

                // si encontramos el destino terminamos BFS
                cond (x == next) then
                    found := 1
                else
                    neigh := adjacentNodes(g2, x);

                    for y in neigh do
                        cond inList(y, visited) then
                            skip
                        else
                            // y no visitado → lo agregamos a la cola
                            q := enqueue(q, y);

                            // registramos padre (VER LO DE USAR edge con peso 0)
                            parent := addList(parent, edge(y, x, 0))
                        end
                    end
                end
            end;

            cond (found == 1) then
                // salimos del while externo
                q := queue[]    // forzamos corte
            else
                skip
            end
        end;

        // Reconstrucción final: backtracking del camino

        segmento := emptyList;
        actual := next;

        // armamos camino invertido: next → prev
        while !(actual == prev) do
            segmento := addList(segmento, actual);

            // buscamos su padre
            padre := prev; // para el compilador, default
            foundParent := 0;
            for p in parent do
                cond (foundParent == 0) then
                    nodoP := getNode1(p);    // el hijo
                    nodoPadre := getNode2(p); // el padre

                    cond (nodoP == actual) then
                        padre := nodoPadre;
                        foundParent := 1
                    else
                        skip
                    end
                else
                    skip
                end
            end;

            actual := padre
        end;

        // agregamos el nodo de inicio
        segmento := addList(segmento, prev);

        // segmento está invertido → reconstruimos orden normal
        segmentoOrdenado := emptyList;
        while !isEmptyList(segmento) do
            h := headList(segmento);
            segmentoOrdenado := addList(segmentoOrdenado, h);
            segmento := tailList(segmento)
        end;

        // concatenamos al camino global
        for s in segmentoOrdenado do
            caminoReal := addList(caminoReal, s)
        end;

        // avanzar
        prev := next;
        rest := tailList(rest)
    end
end;

print "Camino físico real concatenado:";
print caminoReal